// COMPARACIONES

// CONOCEMOS MUCHOS OPERADORES DE COMPARACIÓN DE LAS MATEMÁTICAS.

// EN JAVASCRIPT SE ESCRIBEN ASÍ:

// MAYOR/MENOR QUE: 'a > b', 'a < b'.

// MAYOR/MENOR O IGUAL QUE: 'a >= b', 'a <= b'.

// IGUAL: 'a == b' (TEN EN CUENTA QUE EL DOBLE SIGNO '==' SIGNIFICA COMPARACIÓN, MIENTRAS QUE UN SOLO SÍMBOLO 'a = b' SIGNIFICARÍA UNA ASIGNACIÓN).

// DISTINTO. EN MATEMÁTICAS LA NOTACIÓN ES '≠', PERO EN JAVASCRIPT SE ESCRIBE COMO UNA ASIGNACIÓN CON UN SIGNO DE EXCLAMACIÓN DELANTE: 'a != b'.

// EN ESTE ARTÍCULO, APRENDEREMOS MÁS SOBRE LOS DIFERENTES TIPOS DE COMPARACIONES Y DE CÓMO LAS REALIZA JAVASCRIPT, INCLUIDAS LAS PECULIARIDADES IMPORTANTES.

// AL FINAL, ENCONTRARÁ UNA BUENA RECETA PARA EVITAR PROBLEMAS RELACIONADAS CON LAS "PECULIARIDADES" DE JAVASCRIPT.

// ------------------------------------------------------------------------------------------------------------------------

// BOOLEANO ES EL RESULTADO

// COMO TODOS LOS DEMÁS OPERADORES, UNA COMPARACIÓN RETORNA UN VALOR. EN ESTE CASO, EL VALOR ES UN BOOLEANO.

// 'true' - SIGNIFICA 'SI', 'CORRECTO' O 'VERDAD'.

// 'false' - SIGNIFICA 'NO', 'EQUIVOCADO' O 'NO VERDAD'.

// POR EJEMPLO:

console.log(2 > 1); // true (correcto)
console.log(2 == 1); // false (incorrecto)
console.log(2 != 1); // true (correcto)
console.log(``)

// EL RESULTADO DE UNA COMPARACIÓN PUEDE ASIGNARSE A UNA VARIABLE, IGUAL QUE CUALQUIER VALOR:

let result = 5 > 4; // true
console.log(result); // true
console.log(``)

// ------------------------------------------------------------------------------------------------------------------------

// COMPARACIÓN DE CADENAS

// PARA VER SI UNA CADENA ES "MAYOR" QUE OTRA, JAVASCRIPT UTILIZA EL LLAMADO ORDEN "DE DICCIONARIO" O "LEXICOGRÁFICO".

// EN OTRAS PALABRAS, LAS CADENAS SE COMPARAN LETRA POR LETRA.

// POR EJEMPLO:

console.log('Z' > 'A'); // true
console.log('Glow' > 'Glee'); // true
console.log('Bee' > 'Be'); // true
console.log(``)

// EL ALGORITMO PARA COMPARAR DOS CADENAS ES SIMPLE:

// 1. COMPARE EL PRIMER CARÁCTER DE AMBAS CADENAS.

// 2. SI EL PRIMER CARÁCTER DE LA PRIMERA CADENA ES MAYOR (O MENOR) QUE EL DE LA OTRA CADENA, ENTONCES LA PRIMERA CADENA ES MAYOR (O MENOR) QUE LA SEGUNDA. HEMOS TERMINADO.

// 3. DE LO CONTRARIO, SI LOS PRIMEROS CARACTERES DE AMBAS CADENAS SON LOS MISMOS, COMPARE LOS SEGUNDOS CARACTERES DE LA MISMA MANERA.

// REPITA HASTA EL FINAL DE CADA CADENA.

// SI AMBAS CADENAS TIENEN LA MISMA LONGITUD, ENTONCES SON IGUALES. DE LO CONTRARIO, LA CADENA MÁS LARGA ES MAYOR.

// EN LOS EJEMPLOS ANTERIORES, LA COMPARACIÓN 'Z' > 'A' LLEGA A UN RESULTADO EN EL PRIMER PASO.

// LA SEGUNDA COMPARACIÓN "Glow" Y "Glee" NECESITAN MÁS PASOS, SE COMPARAN CARÁCTER POR CARÁCTER:

// G ES IGUAL QUE G.

// l ES IGUAL QUE l.

// o ES MAYOR QUE e. DETENTE AQUÍ. LA PRIMERA CADENA ES MAYOR.

// NO ES UN DICCIONARIO REAL, SINO UN ORDEN UNICODE.

// EL ALGORITMO DE COMPARACIÓN DADO ARRIBA ES APROXIMADAMENTE EQUIVALENTE AL UTILIZADO EN LOS DICCIONARIOS O GUÍAS TELEFÓNICAS, PERO NO ES EXACTAMENTE EL MISMO.

// POR EJEMPLO, LAS MAYÚSCULAS IMPORTAN. UNA LETRA MAYÚSCULA "A" NO ES IGUAL A LA MINÚSCULA "a". ¿CUÁL ES MAYOR? LA "a" MINÚSCULA. ¿POR QUÉ? PORQUE EL CARÁCTER EN MINÚSCULAS TIENE UN MAYOR ÍNDICE EN LA TABLA DE CODIFICACIÓN INTERNA QUE UTILIZA JAVASCRIPT (UNICODE). VOLVEREMOS A LOS DETALLES ESPECÍFICOS Y LAS CONSECUENCIAS DE ESTO EN EL CAPÍTULO STRING.

// ------------------------------------------------------------------------------------------------------------------------

// COMPARACIÓN DE DIFERENTES TIPOS

// AL COMPARAR VALORES DE DIFERENTES TIPOS, JAVASCRIPT CONVIERTE LOS VALORES A NÚMEROS.

// POR EJEMPLO:

console.log('2' > 1); // true, la cadena '2' se convierte en el número 2
console.log('01' == 1); // true, la cadena '01' se convierte en el número 1
console.log(``)

// PARA VALORES BOOLEANOS, 'true' SE CONVIERTE EN 1 Y 'false' EN 0.

// POR EJEMPLO:

console.log(true == 1); // true
console.log(false == 0); // true
console.log(``)

// UNA CONSECUENCIA GRACIOSA

// ES POSIBLE QUE AL MISMO TIEMPO:

// DOS VALORES SEAN IGUALES.

// UNO DE ELLOS SEA 'true' COMO BOOLEANO Y EL OTRO SEA 'false' COMO BOOLEANO.

// POR EJEMPLO:


let a = 0;
console.log( Boolean(a)); // false

let b = "0";
console.log( Boolean(b)); // true

console.log(a == b); // true
console.log(``)

// DESDE EL PUNTO DE VISTA DE JAVASCRIPT, ESTE RESULTADO ES BASTANTE NORMAL. UNA COMPARACIÓN DE IGUALDAD CONVIERTE VALORES UTILIZANDO LA CONVERSIÓN NUMÉRICA (DE AHÍ QUE "0" SE CONVIERTA EN 0), MIENTRAS QUE LA CONVERSIÓN EXPLÍCITA BOOLEAN UTILIZA OTRO CONJUNTO DE REGLAS.

// ------------------------------------------------------------------------------------------------------------------------

// IGUALDAD ESTRICTA

// UNA COMPARACIÓN REGULAR DE IGUALDAD == TIENE UN PROBLEMA. NO PUEDE DIFERENCIAR 0 DE 'falso'

console.log(0 == false); // true
console.log(``)

// LO MISMO SUCEDE CON UNA CADENA VACÍA:

console.log('' == false ); // true
console.log(``)

// ESTO SUCEDE PORQUE LOS OPERANDOS DE DIFERENTES TIPOS SON CONVERTIDOS A NÚMEROS POR EL OPERADOR DE IGUALDAD '=='. UNA CADENA VACÍA, AL IGUAL QUE 'false', SE CONVIERTE EN UN CERO.

// ¿QUÉ HACER SI QUEREMOS DIFERENCIAR 0 DE 'false'?

// UN OPERADOR DE IGUALDAD ESTRICTO '===' COMPRUEBA LA IGUALDAD SIN CONVERSIÓN DE TIPO.

// EN OTRAS PALABRAS, SI 'a' Y 'b' SON DE DIFERENTES TIPOS, ENTONCES 'a === b' RETORNA INMEDIATAMENTE 'false' SIN INTENTAR CONVERTIRLOS.

// INTENTÉMOSLO:

console.log(0 === false); // falso, porque los tipos son diferentes
console.log(``)

// EXISTE TAMBIÉN UN OPERADOR DE DIFERENCIA ESTRICTA '!==' ANÁLOGO A '!='.

// EL OPERADOR DE IGUALDAD ESTRICTA ES UN POCO MÁS LARGO DE ESCRIBIR, PERO HACE OBVIO LO QUE ESTÁ PASANDO Y DEJA MENOS ESPACIO A ERRORES.

// ------------------------------------------------------------------------------------------------------------------------

// COMPARACIÓN CON NULOS E INDEFINIDOS

// VEAMOS MÁS CASOS EXTREMOS.

// HAY UN COMPORTAMIENTO NO INTUITIVO CUANDO SE COMPARA null O undefined CON OTROS VALORES.

// PARA UN CONTROL DE IGUALDAD ESTRICTO '==='

// ESTOS VALORES SON DIFERENTES, PORQUE CADA UNO DE ELLOS ES DE UN TIPO DIFERENTE.

console.log(null === undefined); // false
console.log(``)

// PARA UNA COMPARACIÓN NO ESTRICTA '=='

// HAY UNA REGLA ESPECIAL. ESTOS DOS SON UNA "PAREJA DULCE", SON IGUALES ENTRE SÍ (EN EL SENTIDO DE ==), PERO NO A NINGÚN OTRO VALOR.

console.log( null == undefined ); // true
console.log(``)

// PARA MATEMÁTICAS Y OTRAS COMPARACIONES < > <= >=

// 'null/undefined' SE CONVIERTEN EN NÚMEROS: 'null' SE CONVIERTE EN 0, MIENTRAS QUE 'undefined' SE CONVIERTE EN 'NaN'.

// AHORA VEAMOS ALGUNOS HECHOS GRACIOSOS QUE SUCEDEN CUANDO APLICAMOS ESTAS REGLAS. Y, LO QUE ES MÁS IMPORTANTE, CÓMO NO CAER EN UNA TRAMPA CON ELLAS.

// RESULTADO EXTRAÑO: 'null' vs '0'

// COMPAREMOS null CON UN CERO:

console.log(null > 0); /// (1) false
console.log(null == 0); /// (2) false
console.log(null >= 0); // (3) true
console.log(``)

// UN INDEFINIDO INCOMPARABLE

// EL VALOR 'undefined' NO DEBE COMPARARSE CON OTROS VALORES:

console.log(undefined > 0); // false (1)
console.log(undefined < 0); // false (2)
console.log(undefined == 0); // false (3)
console.log(``)

// ¿POR QUÉ LE DESAGRADA TANTO EL CERO? ¡SIEMPRE FALSO!

// OBTENEMOS ESTOS RESULTADOS PORQUE:

// LAS COMPARACIONES (1) Y (2) RETORNAN 'false' PORQUE NO DEFINIDO SE CONVIERTE EN 'NaN' Y 'NaN' ES UN VALOR NUMÉRICO ESPECIAL QUE RETORNA 'false' PARA TODAS LAS COMPARACIONES.

// LA COMPARACIÓN DE IGUALDAD (3) RETORNA 'false' PORQUE 'undefined' SÓLO EQUIVALE A 'null' Y A NINGÚN OTRO VALOR.

// EVITAR LOS PROBLEMAS

// ¿POR QUÉ REPASAMOS ESTOS EJEMPLOS? ¿DEBERÍAMOS RECORDAR ESTAS PECULIARIDADES TODO EL TIEMPO? BUENO, EN REALIDAD NO. DE HECHO, ESTAS PECULIARIDADES SE VOLVERÁN FAMILIARES CON EL TIEMPO, PERO HAY UNA MANERA SÓLIDA DE EVADIR LOS PROBLEMAS CON ELLAS:

// TRATA CUALQUIER COMPARACIÓN CON 'undefined/null' (EXCEPTO LA IGUALDAD ESTRICTA ===) CON SUMO CUIDADO.

// NO USES COMPARACIONES >= > < <= CON UNA VARIABLE QUE PUEDE SER null/undefined, A MENOS QUE ESTÉS REALMENTE SEGURO DE LO QUE ESTÁS HACIENDO. SI UNA VARIABLE PUEDE TENER ESTOS VALORES, VERIFÍCALOS POR SEPARADO.